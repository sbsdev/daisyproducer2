#+title: Architecture Decision Records
#+date: <2024-02-15 Do>
#+author: Christian Egli
#+email: christian.egli@sbs.ch
#+language: en

#+TODO: DRAFT PROPOSED | ACCEPTED REJECTED DEPRECATED SUPERSEDED

* DRAFT "Unignore" unknown words
- Deciders :: CE, MK
- Date :: [2024-02-21 Mi]

Unknown words can be "ignored", i.e. marked as ignored and they will
be put at the end of the list. In the paginated view of the unknown
words an ignored word will simply show up on the last page once the
transcriber has worked though all the non-ignored words.

** Context and Problem Statement

When an unknown word is confirmed an entry for this word is created in
the table for local words. The entry in the table for unknown words is
not changed. However the query for unknown words will no longer
contain that word in the resultset, as it only returns unknown words
that are not in the local words table.

So when a local word is deleted the query for unknown words will
return that word again in its resultset. So far all is fine.

However, as the row for that word in the table for unknown words has
not been touched, the unknown word will still be marked as ignored.
Does that make sense? And in a broader sense: do we need a way to
"unignore" an unknown word?

** Decision Drivers

- Make the UI as simple as possible
- Make the UI as understandable as possible
- Make the REST API as contrained as possible
  - i.e. do not make the PUT end point of local words also reset the
    ignored status of the same unknown word

** Considered Options

- Ignore the problem :: the usecase is so rare that the users will
  almost never run into this situation
- Disable ignore button for ignored words :: Basically the same as
  ignoring the problem but make it visible that a words is ingored by
  disabling the button. "Ignoring" an already ignored unknown word
  indeed does not make much sense.
- Add an "Unignore" button :: Make the "Ignore" button a toggle that
  lets you ignore and "unignore" a word
- Clear the ignored state on confirm :: When confirming an unknown
  word set the ignored flag to false

** Decision Outcome

Chosen option: "[option 1]", because [justification. e.g., only option,
which meets k.o. criterion decision driver | which resolves force force
| ... | comes out best (see below)].

*** Positive Consequences

- [e.g., improvement of quality attribute satisfaction, follow-up
  decisions required, ...]
- ...

*** Negative Consequences

- [e.g., compromising quality attribute, follow-up decisions required,
  ...]
- ...

** Pros and Cons of the Options

*** [option 1]

[example | description | pointer to more information | ...]

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- ...

*** [option 2]

[example | description | pointer to more information | ...]

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- ...

*** [option 3]

[example | description | pointer to more information | ...]

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- ...

** Links

* ACCEPTED Show totals in paginated views
CLOSED: [2024-02-20 Di 11:26]
- Deciders :: CE
- Date :: [2024-02-15 Do]

** Context and Problem Statement

The query to get the unknown words is very complex and costly. It
currently only returns a subset of the unknown words as they are
paginated in the UI anyway. Now we would also like to see the total of
the unknown words. How do we display the total without having to do
the expensive query twice?

** Decision Drivers

- The request to get the unknown words needs to be fast

** Considered Options

- Two selects :: Using two selects, first using LIMIT and then a
  second one to get the total
- Independent selects :: There are two selects as above and the client
  asks for the information separately. I.e. the client determines when
  it asks for the information and how much of it is cached and locally
  maintained.
- ~SQL_CALC_FOUND_ROWS~ :: Using ~SQL_CALC_FOUND_ROWS~ as outlined in
  [[https://stackoverflow.com/q/818567][MySQL pagination without double-querying?]]

** Decision Outcome

Chosen option: "Independent selects", firstly because MySQL seems to
shy away from the ~SQL_CALC_FOUND_ROWS~ solution. It is deprecated as
of 8.0.17, see https://stackoverflow.com/a/62328373. Secondly leaving
it up to the client when to fetch the totals information gives us more
room for optimization, such as caching and/or just approximated
totals.

*** Positive Consequences

*** Negative Consequences

- Most of the code for the second query (to get the total) is
  duplicated from the first query. It is not quite the same though as
  it can be kept simpler.

** Pros and Cons of the Options

*** Two selects

There are two selects, but they could possibly be combined in one REST
end point. This ties the two together at least from the POV of the
client. This can make sense some time but probably most of the time
the two concerns are separate.

- Bad :: complects two mostly independent concerns

*** Independent selects

There are two concerns:

1. get a possibly paginated set of words
2. get the total number of words

These two concerns can be nicely served be two requests. The first one
is plain old REST call (~GET /api/collection~) to get the list of
words. The second one is a bit special and the idea comes from this [[https://stackoverflow.com/q/1610862][SO
question]] about "Getting a count of returns seen by a RESTful
request". The basic idea is that you send a ~HEAD~ request to the
collection and the response contains the count as meta data in the
headers.

- Good :: separates fetching the words from fetching the count
- Good :: the count just returns meta data without a body

*** ~SQL_CALC_FOUND_ROWS~

Even MySQL is dropping it, so that one is out

- Bad :: deprecated, see https://stackoverflow.com/a/62328373

** Links

- https://stackoverflow.com/q/1610862

* ACCEPTED Cleanup of dictionary_unknownword table
CLOSED: [2024-02-16 Fr 09:24]
- Deciders :: CE
- Date :: [2024-02-15 Do]

To calculate the unknown words there is some sort of a "temporary"
table that holds the extracted words from a document. This table
should probably be cleaned up once the document has been finished.

** Context and Problem Statement

The calculation of the unknown words is expensive. Previously they
were calculated when the request came in. Now the extraction of
unknown words from the XML is done when the XML is uploaded. But these
words aren't removed from the table ever. Should they be removed?

** Decision Drivers

- many rows in the table make the very complex SQL query to find
  unknown words slower
- removing them when the status changes couples the two actions too
  much, i.e. the state change and the cleanup
- Potentially there could be many cleanup jobs
  - cleanup unknown words
  - remove images
  - remove old versions
- the user is not interested in the cleanup, i.e. this is just an
  implementation detail

** Considered Options

- Do not remove :: 
- Asynchronously :: remove them with a cron job, kinda like garbage
  collection
- Synchronously :: remove them when the status of the document is set
  to fninished

** Decision Outcome

Chosen option: "Asynchronously", because this keeps the two issues
separate. The state is changed immediately but the garbage is cleaned
up later/asynchronously.

*** Positive Consequences

- The response to state change is fast, as the clean is done later

*** Negative Consequences

- No user feedback that the cleanup is done

** Pros and Cons of the Options

*** Do not remove

- Good :: easy to implement
- Good :: predictable
- Bad :: waste of disc space
- Bad :: unknown words query will get slower

*** Asynchronously

The status is changed by the user but the cleanup is done
independently sometime later.

- Good :: relatively simple to implement as they are independent parts
  with no UI
- Bad :: errors are only visible to the administrators
  - but the users are not interested in these kinds of errors

*** Synchronously

The status is changed by the user and the cleanup is part of it.

- Good :: predictable
- Good :: feedback to the user if anything fails
- Bad :: state change request takes a long time
- Bad :: quite a bit of effort to implement

** Links

- [[https://github.com/sbsdev/daisyproducer2/blob/8fb6d4e4dd26e326be8050c6db2b98b9c4452fdd/src/clj/daisyproducer2/whitelists/async.clj#L60][See how cron jobs are handled for global white lists]]
- https://github.com/sbsdev/daisyproducer2/commit/94974e90a2ec28e8d6786fc28b11ecaa254c925b

* ACCEPTED Pagination for versions and images
CLOSED: [2024-02-15 Do 16:37]
- Deciders :: CE
- Date :: [2024-02-14 Mi]

The unknown words do have pagination. To be orthogonal it seems
logical that the list of versions and images also have pagination

** Context and Problem Statement

Pagination makes the version and image pages much more complicated
especially in the light of deletion of single elements. With
pagination we will have to do a re-fetch each time you delete an
element, so we can have a full window of elements again.

** Decision Drivers

- the old UI did *not* have pagination
- at least for versions we rarely have more than a handful of versions
  - so pagination seems pointless
- there is search on the page
- I don't think the users want to paginate through images let alone
  versions
- the code is much more complicated

** Considered Options

- Dropping pagination :: for images and versions
- Implementing pagination :: for images and versions

** Decision Outcome

Chosen option: "Dropping pagination", because the cost of maintaining
it is too high compared with the user benefit.

*** Positive Consequences

- Code is much simpler
- no weird re-draw effects when re-fetching the items

*** Negative Consequences

- The user cannot paginate.

** Links

- https://github.com/sbsdev/daisyproducer2/commit/fdb4de711de77f710fe6bd970c19c903772b41ca
- https://github.com/sbsdev/daisyproducer2/commit/62609888ae0442daa7de40bf0cb79665f689543b

* COMMENT [short title of solved problem and solution]                     :Template:
- Status :: [proposed | rejected | accepted | deprecated | ... |
  superseded by [[file:0005-example.md][ADR-0005]]]
- Deciders :: [list everyone involved in the decision]
- Date :: [YYYY-MM-DD when the decision was last updated]

Technical Story: [description | ticket/issue URL]

** Context and Problem Statement

[Describe the context and problem statement, e.g., in free form using
two to three sentences. You may want to articulate the problem in form
of a question.]

** Decision Drivers

- [driver 1, e.g., a force, facing concern, ...]
- [driver 2, e.g., a force, facing concern, ...]
- ...

** Considered Options

- [option 1]
- [option 2]
- [option 3]
- ...

** Decision Outcome

Chosen option: "[option 1]", because [justification. e.g., only option,
which meets k.o. criterion decision driver | which resolves force force
| ... | comes out best (see below)].

*** Positive Consequences

- [e.g., improvement of quality attribute satisfaction, follow-up
  decisions required, ...]
- ...

*** Negative Consequences

- [e.g., compromising quality attribute, follow-up decisions required,
  ...]
- ...

** Pros and Cons of the Options

*** [option 1]

[example | description | pointer to more information | ...]

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- ...

*** [option 2]

[example | description | pointer to more information | ...]

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- ...

*** [option 3]

[example | description | pointer to more information | ...]

- Good, because [argument a]
- Good, because [argument b]
- Bad, because [argument c]
- ...

** Links

- [Link type] [Link to ADR]
- ...
